/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <assert.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
#include <utime.h>

#ifdef HAVE_SYS_XATTR_H
#include <sys/xattr.h>
#endif

#include "fuse_rpc.h"

typedef enum {
    false,
    true
} bool;

getattr_ret *
bb_getattr_6_svc(getattr_arg *argp, struct svc_req *rqstp)
{
	char *path = argp->path;
	fprintf(stderr, "Get attribute for path = %s\n", path);
	
	static getattr_ret result;

    struct stat statbuf;
    if (lstat(path, &statbuf) == -1) {
        fprintf(stderr, "lstat %s error\n", path);
        result.ret = -errno;
        return &result;
    }

    result.st_dev = statbuf.st_dev;
    result.st_ino = statbuf.st_ino;
    result.st_mode = statbuf.st_mode;
    result.st_nlink = statbuf.st_nlink;
    result.st_uid = statbuf.st_uid;
    result.st_gid = statbuf.st_gid;
    result.st_rdev = statbuf.st_rdev;
    result.st_size = statbuf.st_size;
    result.st_blksize = statbuf.st_blksize;
    result.st_blocks = statbuf.st_blocks;
    result.st_atimensec = statbuf.st_atim.tv_nsec;
    result.st_mtimensec = statbuf.st_mtim.tv_nsec;
    result.st_ctimensec = statbuf.st_ctim.tv_nsec;
    result.ret = 0;

	return &result;
}

access_ret *
bb_access_6_svc(access_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    int mask = argp->mask;
	fprintf(stderr, "Access for path = %s, with mask = %d\n", path, mask);
    
    static access_ret result;
    result.ret = access(path, mask);
    return &result;
}

mkdir_ret *
bb_mkdir_6_svc(mkdir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    int mode = argp->mode;
    fprintf(stderr, "Make directory for %s with mode %d\n", path, mode);

    static mkdir_ret ret;
    ret.ret = mkdir(path, mode);
    return &ret;
}

rmdir_ret *
bb_rmdir_6_svc(rmdir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Remove directory for %s\n", path);

    static rmdir_ret ret;
    ret.ret = rmdir(path);
    return &ret;
}

readdir_ret *
bb_readdir_6_svc(readdir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Read directory for %s\n", path);

    static readdir_ret ret; 
    ret.count = 0;
    DIR *dp = opendir(path);
    if (dp == NULL) {
        fprintf(stderr, "opendir %s error\n", path);
        ret.ret = -errno;
        return &ret;
    }

    // Iterate through the dirent, and fill it into entry.
    int offset = 0;
    static char buf[MAX_SIZE];
    memset(buf, '\0', MAX_SIZE);
    struct dirent *de = NULL;
    while ((de = readdir(dp)) != NULL) {
        char *entry_name = de->d_name;
        int len = strlen(entry_name);
        memcpy(buf + offset, entry_name, len);
        offset += len + 1;
        ++ret.count;
    }
    ret.ret = 0;
    memcpy(ret.entries, buf, MAX_SIZE);
    return &ret;
}

opendir_ret *
bb_opendir_6_svc(opendir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Open directory for %s\n", path);

    static opendir_ret ret;
    memset((char*)&ret, 0, sizeof(ret));
    DIR *dp = opendir(path);
    if (dp == NULL) {
        fprintf(stderr, "opendir %s error\n", path);
        ret.ret = -errno;
        return &ret;
    }

    ret.fd = dirfd(dp);
    ret.ret = 0;
    return &ret;
}

releasedir_ret *
bb_releasedir_6_svc(releasedir_arg *argp, struct svc_req *rqstp) {
    int fd = argp->fd;
    fprintf(stderr, "Close directory with fd = %d\n", fd);

    static releasedir_ret ret;
    DIR* dir = fdopendir(fd);
    if (dir == NULL) {
        fprintf(stderr, "Open directory associated with fd %d error\n", fd);
        ret.ret = -errno;
        return &ret;
    }
    int close_ret = closedir(dir);
    if (close_ret == -1) {
        fprintf(stderr, "Close directory error\n");
        ret.ret = -errno;
        return &ret;
    }

    ret.ret = 0;
    return &ret;
}

rename_ret *
bb_rename_6_svc(rename_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    char *newpath = argp->newpath;
    fprintf(stderr, "Rename file from %s to %s\n", path, newpath);

    static rename_ret ret;
    ret.ret = rename(path, newpath);
    return &ret;
}

symlink_ret *
bb_symlink_6_svc(symlink_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    char *link = argp->link;
    fprintf(stderr, "Create symlink target = %s, original path = %s\n", link, path);

    static symlink_ret ret;
    int syscall_ret = symlink(path, link);
    if (syscall_ret == -1) {
        fprintf(stderr, "symlink error for creating link %s to file %s\n", link, path);
        ret.ret = -errno;
        return &ret;
    }
    ret.ret = 0;
    return &ret;
}

readlink_ret *
bb_readlink_6_svc(readlink_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    unsigned int size = argp->size;
    fprintf(stderr, "Read link %s with size %u\n", path, size);

    static readlink_ret ret;
    static char buffer[MAX_SIZE];
    memset(buffer, '\0', MAX_SIZE);
    ssize_t read_len = readlink(path, buffer, size);

    if (read_len == -1) {
        fprintf(stderr, "read link %s, with size = %u error with errno %d\n", path, size, errno);
        ret.ret = -errno;
        return &ret;
    }

    ret.len = read_len;
    ret.ret = 0;
    memcpy(ret.buffer, buffer, MAX_SIZE);
    return &ret;
}

mknod_ret *
bb_mknod_6_svc(mknod_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    int mode = argp->mode;
    int dev = argp->dev;
    fprintf(stderr, "Mknod for file %s with mode %d and dev %d\n", path, mode, dev);

    static mknod_ret ret;
    int func_ret = -1;

    // Create file, close it if succeeds.
    if (S_ISREG(mode)) {
        func_ret = open(path, O_CREAT | O_EXCL | O_WRONLY, mode);
        if (func_ret < 0) {
            fprintf(stderr, "mknod for regular file %s with mode %d with errno %d\n", path, mode, -errno);
            ret.ret = -errno;
            return &ret;
        } else {
            close(func_ret);
        }
    }

    // Create fifo.
    else if (S_ISFIFO(mode)) {
        func_ret = mkfifo(path, mode);
        if (func_ret < 0) {
            fprintf(stderr, "mknod for fifo file %s with mode %d with errno %d\n", path, mode, -errno);
            ret.ret = -errno;
            return &ret;
        }
    }

    // Create device files.
    else {
        func_ret = mknod(path, mode, dev);
        if (func_ret < 0) {
            fprintf(stderr, "mknod for device file %s with mode %d device id %d with errno %d\n", path, mode, dev, -errno);
            ret.ret = -errno;
            return &ret;
        }
    }

    ret.ret = 0;
    return &ret;
}

utime_ret *
bb_utime_6_svc(utime_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    long actime = argp->actime;
    long modtime = argp->modtime;
    fprintf(stderr, "Utime %s with access time %ld and modification time %ld\n", path, actime, modtime);

    static utime_ret ret;
    struct utimbuf ubuf;
    ubuf.actime = actime;
    ubuf.modtime = modtime;
    int syscall_ret = utime(path, &ubuf);
    if (syscall_ret < 0) {
        fprintf(stderr, "utime %s with access time %ld and modification time %ld error with errno %d\n", path, actime, modtime, errno);
        ret.ret = -errno;
        return &ret;
    }
    
    ret.ret = 0;
    return &ret;
}

truncate_ret *
bb_truncate_6_svc(truncate_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    int newsize = argp->newsize;
    fprintf(stderr, "Truncate file %s to new size %d\n", path, newsize);

    static truncate_ret ret;
    int syscall_ret = truncate(path, newsize);
    if (syscall_ret < 0) {
        fprintf(stderr, "truncate file %s to new size %d fail with errno %d\n", path, newsize, errno);
        ret.ret = -errno;
        return &ret;
    }
    
    ret.ret = 0;
    return &ret;
}

unlink_ret *
bb_unlink_6_svc(unlink_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Unlink file for %s\n", path);

    static unlink_ret ret;
    ret.ret = unlink(path);
    return &ret;
}

open_ret *
bb_open_6_svc(open_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    int flags = argp->flags;
    fprintf(stderr, "Open file for %s with flag %d\n", path, flags);

    static open_ret ret;
    ret.fd = open(path, flags);
    if (ret.fd == -1) {
        fprintf(stderr, "open file %s with flag %d error with errno %d\n", path, flags, errno);
        ret.ret = -errno;
        return &ret;
    }

    ret.ret = 0;
    return &ret;
}

release_ret *
bb_release_6_svc(release_arg *argp, struct svc_req *rqstp) {
    int fd = argp->fd;
    fprintf(stderr, "Close file with fd %d\n", fd);

    static release_ret ret;
    int close_ret = close(fd);
    if (close_ret == -1) {
        fprintf(stderr, "Close fd %d\n error\n", fd);
        ret.ret = -1;
        return &ret;
    }

    ret.ret = 0;
    return &ret;
}

read_ret *
bb_read_6_svc(read_arg *argp, struct svc_req *rqstp) {
    int fd = argp->fd;
    unsigned int size = argp->size;
    unsigned int offset = argp->offset;
    fprintf(stderr, "Read file with fd = %d, with size = %u, offset = %u\n", fd, size, offset);

    static read_ret ret;
    static char buf[MAX_SIZE];
    memset(buf, '\0', MAX_SIZE);
    ssize_t read_len = pread(fd, buf, size, offset);

    if (read_len == -1) {
        fprintf(stderr, "read file with fd = %d, with size = %u, offset = %u error with errno %d\n", fd, size, offset, errno);
        ret.ret = -errno;
        return &ret;
    }

    // read_len could be 0, which means server has reached EOF.
    ret.len = read_len;
    ret.ret = 0;
    memcpy(ret.buffer, buf, MAX_SIZE);
    return &ret;
}

write_ret *
bb_write_6_svc(write_arg *argp, struct svc_req *rqstp) {
    int fd = argp->fd;
    unsigned int size = argp->size;
    unsigned int offset = argp->offset;
    char *buf = argp->buffer;
    fprintf(stderr, "Write file with fd = %d, with size = %u, offset = %u\n", fd, size, offset);

    static write_ret ret;
    ssize_t write_ret = pwrite(fd, buf, size, offset);

    if (write_ret == -1) {
        fprintf(stderr, "write file with fd = %d, with size = %u, offset = %u error\n", fd, size, offset);
        ret.ret = -errno;
        return &ret;    
    }

    ret.len = write_ret;
    ret.ret = 0;
    return &ret;
}