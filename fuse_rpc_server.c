/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <assert.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

#ifdef HAVE_SYS_XATTR_H
#include <sys/xattr.h>
#endif

#include "fuse_rpc.h"

typedef enum {
    false,
    true
} bool;

getattr_ret *
bb_getattr_6_svc(getattr_arg *argp, struct svc_req *rqstp)
{
	char *path = argp->path;
	fprintf(stderr, "Get attribute for path = %s\n", path);
	
	static getattr_ret result;

    struct stat statbuf;
    if (lstat(path, &statbuf) == -1) {
        fprintf(stderr, "lstat %s error\n", path);
        result.ret = -1;
        return &result;
    }

    result.st_dev = statbuf.st_dev;
    result.st_ino = statbuf.st_ino;
    result.st_mode = statbuf.st_mode;
    result.st_nlink = statbuf.st_nlink;
    result.st_uid = statbuf.st_uid;
    result.st_gid = statbuf.st_gid;
    result.st_rdev = statbuf.st_rdev;
    result.st_size = statbuf.st_size;
    result.st_blksize = statbuf.st_blksize;
    result.st_blocks = statbuf.st_blocks;
    result.st_atimensec = statbuf.st_atim.tv_nsec;
    result.st_mtimensec = statbuf.st_mtim.tv_nsec;
    result.st_ctimensec = statbuf.st_ctim.tv_nsec;
    result.ret = 0;

	return &result;
}

access_ret *
bb_access_6_svc(access_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    int mask = argp->mask;
	fprintf(stderr, "Access for path = %s, with mask = %d\n", path, mask);
    
    static access_ret result;
    result.ret = access(path, mask);
    return &result;
}

mkdir_ret *
bb_mkdir_6_svc(mkdir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    int mode = argp->mode;
    fprintf(stderr, "Make directory for %s with mode %d\n", path, mode);

    static mkdir_ret ret;
    ret.ret = mkdir(path, mode);
    return &ret;
}

rmdir_ret *
bb_rmdir_6_svc(rmdir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Remove directory for %s\n", path);

    static rmdir_ret ret;
    ret.ret = rmdir(path);
    return &ret;
}

readdir_ret *
bb_readdir_6_svc(readdir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Read directory for %s\n", path);

    static readdir_ret ret; 
    ret.count = 0;
    DIR *dp = opendir(path);
    if (dp == NULL) {
        fprintf(stderr, "opendir %s error\n", path);
        ret.ret = -1;
        return &ret;
    }

    // Iterate through the dirent, and fill it into entry.
    int offset = 0;
    static char buf[MAX_SIZE];
    memset(buf, '\0', MAX_SIZE);
    struct dirent *de = NULL;
    while ((de = readdir(dp)) != NULL) {
        char *entry_name = de->d_name;
        int len = strlen(entry_name);
        memcpy(buf + offset, entry_name, len);
        offset += len + 1;
        ++ret.count;
    }
    ret.ret = 0;
    memcpy(ret.entries, buf, MAX_SIZE);
    return &ret;
}

opendir_ret *
bb_opendir_6_svc(opendir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Open directory for %s\n", path);

    static opendir_ret ret;
    memset((char*)&ret, 0, sizeof(ret));
    DIR *dp = opendir(path);
    if (dp == NULL) {
        fprintf(stderr, "opendir %s error\n", path);
        ret.ret = -1;
        return &ret;
    }

    ret.fd = dirfd(dp);
    ret.ret = 0;
    return &ret;
}

releasedir_ret *
bb_releasedir_6_svc(releasedir_arg *argp, struct svc_req *rqstp) {
    int fd = argp->fd;
    fprintf(stderr, "Close directory with fd = %d\n", fd);

    static releasedir_ret ret;
    DIR* dir = fdopendir(fd);
    if (dir == NULL) {
        fprintf(stderr, "Open directory associated with fd %d error\n", fd);
        ret.ret = -1;
        return &ret;
    }
    int close_ret = closedir(dir);
    if (close_ret == -1) {
        fprintf(stderr, "Close directory error\n");
        ret.ret = -1;
        return &ret;
    }

    ret.ret = 0;
    return &ret;
}

rename_ret *
bb_rename_6_svc(rename_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    char *newpath = argp->newpath;
    fprintf(stderr, "Rename file from %s to %s\n", path, newpath);

    static rename_ret ret;
    ret.ret = rename(path, newpath);
    return &ret;
}

symlink_ret *
bb_symlink_6_svc(symlink_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    char *link = argp->link;
    fprintf(stderr, "Create symlink target = %s, original path = %s\n", link, path);

    static symlink_ret ret;
    ret.ret = symlink(path, link);
    return &ret;
}

unlink_ret *
bb_unlink_6_svc(unlink_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Unlink file for %s\n", path);

    static unlink_ret ret;
    ret.ret = unlink(path);
    return &ret;
}

open_ret *
bb_open_6_svc(open_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    int flags = argp->flags;
    fprintf(stderr, "Open file for %s with flag %d\n", path, flags);

    static open_ret ret;
    ret.fd = open(path, flags);
    if (ret.fd == -1) {
        fprintf(stderr, "open file %s with flag %d error\n", path, flags);
        ret.ret = -1;
        return &ret;
    }

    fprintf(stderr, "fd for file %s is %d\n", path, ret.fd);

    // char buf[MAX_SIZE];
    // ssize_t read_ret = pread(fd, buf, 4096, 0);
    // fprintf(stderr, "Try read file when open: %s\n", buf);

    ret.ret = 0;
    return &ret;
}

release_ret *
bb_release_6_svc(release_arg *argp, struct svc_req *rqstp) {
    int fd = argp->fd;
    fprintf(stderr, "Close file with fd %d\n", fd);

    static release_ret ret;
    int close_ret = close(fd);
    if (close_ret == -1) {
        fprintf(stderr, "Close fd %d\n error\n", fd);
        ret.ret = -1;
        return &ret;
    }

    ret.ret = 0;
    return &ret;
}

read_ret *
bb_read_6_svc(read_arg *argp, struct svc_req *rqstp) {
    int fd = argp->fd;
    unsigned int size = argp->size;
    unsigned int offset = argp->offset;
    fprintf(stderr, "Read file with fd = %d, with size = %u, offset = %u\n", fd, size, offset);

    static read_ret ret;
    static char buf[MAX_SIZE];
    memset(buf, '\0', MAX_SIZE);
    ssize_t read_ret = pread(fd, buf, size, offset);

    if (read_ret == -1) {
        ret.ret = -1;
        fprintf(stderr, "read file with fd = %d, with size = %u, offset = %u error\n", fd, size, offset);
        return &ret;
    }

    // read_ret could be 0, which means server has reached EOF.
    ret.len = read_ret;
    ret.ret = 0;
    memcpy(ret.buffer, buf, MAX_SIZE);
    return &ret;
}

write_ret *
bb_write_6_svc(write_arg *argp, struct svc_req *rqstp) {
    int fd = argp->fd;
    unsigned int size = argp->size;
    unsigned int offset = argp->offset;
    char *buf = argp->buffer;
    fprintf(stderr, "Write file with fd = %d, with size = %u, offset = %u\n", fd, size, offset);

    static write_ret ret;
    ssize_t write_ret = pwrite(fd, buf, size, offset);

    if (write_ret == -1) {
        ret.ret = -1;
        fprintf(stderr, "write file with fd = %d, with size = %u, offset = %u error\n", fd, size, offset);
        return &ret;    
    }

    ret.len = write_ret;
    ret.ret = 0;
    return &ret;
}