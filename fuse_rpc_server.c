/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <assert.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

#ifdef HAVE_SYS_XATTR_H
#include <sys/xattr.h>
#endif

#include "fuse_rpc.h"

typedef enum {
    false,
    true
} bool;

getattr_ret *
bb_getattr_6_svc(getattr_arg *argp, struct svc_req *rqstp)
{
	char *path = argp->path;
	fprintf(stderr, "Get attribute for path = %s\n", path);
	
	static getattr_ret result;

    struct stat statbuf;
    if (lstat(path, &statbuf) == -1) {
        fprintf(stderr, "lstat %s error\n", path);
        result.ret = -1;
        return &result;
    }

    result.st_dev = statbuf.st_dev;
    result.st_ino = statbuf.st_ino;
    result.st_mode = statbuf.st_mode;
    result.st_nlink = statbuf.st_nlink;
    result.st_uid = statbuf.st_uid;
    result.st_gid = statbuf.st_gid;
    result.st_rdev = statbuf.st_rdev;
    result.st_size = statbuf.st_size;
    result.st_blksize = statbuf.st_blksize;
    result.st_blocks = statbuf.st_blocks;
    result.st_atimensec = statbuf.st_atim.tv_nsec;
    result.st_mtimensec = statbuf.st_mtim.tv_nsec;
    result.st_ctimensec = statbuf.st_ctim.tv_nsec;
    result.ret = 0;

	return &result;
}

access_ret *
bb_access_6_svc(access_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    int mask = argp->mask;
	fprintf(stderr, "Access for path = %s, with mask = %d\n", path, mask);
    
    static access_ret result;
    result.ret = access(path, mask);
    return &result;
}

readdir_ret *
bb_readdir_6_svc(readdir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Read directory for %s\n", path);

    static readdir_ret ret; 
    ret.count = 0;
    DIR *dp = opendir(path);
    if (dp == NULL) {
        fprintf(stderr, "opendir %s error\n", path);
        ret.ret = -1;
        return &ret;
    }

    // Iterate through the dirent, and fill it into entry.
    int offset = 0;
    static char buf[MAX_SIZE];
    memset(buf, '\0', MAX_SIZE);
    struct dirent *de = NULL;
    while ((de = readdir(dp)) != NULL) {
        char *entry_name = de->d_name;
        int len = strlen(entry_name);
        memcpy(buf + offset, entry_name, len);
        offset += len + 1;
        ++ret.count;
    }
    ret.ret = 0;
    memcpy(ret.entries, buf, MAX_SIZE);
    return &ret;
}

opendir_ret *
bb_opendir_6_svc(opendir_arg *argp, struct svc_req *rqstp) {
    char *path = argp->path;
    fprintf(stderr, "Open directory for %s\n", path);

    static opendir_ret ret;
    memset((char*)&ret, 0, sizeof(ret));
    DIR *dp = opendir(path);
    if (dp == NULL) {
        fprintf(stderr, "opendir %s error\n", path);
        ret.ret = -1;
        return &ret;
    }

    ret.ret = 0;
    return &ret;
}